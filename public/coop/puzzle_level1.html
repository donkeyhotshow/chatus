<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>–ö–æ–æ–ø–µ—Ä–∞—Ç–∏–≤–Ω–∞—è –ì–æ–ª–æ–≤–æ–ª–æ–º–∫–∞ - –£—Ä–æ–≤–µ–Ω—å 1</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
    padding: 20px;
    color: #fff;
    min-height: 100vh;
}
.container {
    max-width: 900px;
    margin: 0 auto;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 12px;
    padding: 20px;
    backdrop-filter: blur(10px);
    box-shadow: 0 10px 40px rgba(0,0,0,0.3);
}
h2 {
    text-align: center;
    color: #fff;
    margin-bottom: 15px;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
}
.controls {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    margin-bottom: 15px;
    padding: 15px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 8px;
    align-items: center;
}
.controls input {
    padding: 8px 12px;
    border: 2px solid rgba(255, 255, 255, 0.3);
    border-radius: 6px;
    font-size: 14px;
    background: rgba(255, 255, 255, 0.9);
    color: #333;
}
.controls button {
    padding: 8px 16px;
    border: none;
    border-radius: 6px;
    background: #4CAF50;
    color: white;
    cursor: pointer;
    font-size: 14px;
    font-weight: 600;
    transition: all 0.3s;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
}
.controls button:hover {
    background: #45a049;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
}
.controls button:active {
    transform: translateY(0);
}
.controls button.secondary {
    background: #2196F3;
}
.controls button.secondary:hover {
    background: #0b7dda;
}
.controls button.danger {
    background: #f44336;
}
.controls button.danger:hover {
    background: #da190b;
}
#game {
    border: 3px solid rgba(255, 255, 255, 0.3);
    border-radius: 8px;
    display: block;
    margin: 0 auto 15px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    background: #f0f0f0;
}
#chat {
    display: flex;
    gap: 10px;
    margin-top: 15px;
}
#messages {
    flex: 1;
    height: 120px;
    overflow-y: auto;
    border: 2px solid rgba(255, 255, 255, 0.3);
    border-radius: 6px;
    padding: 10px;
    background: rgba(255, 255, 255, 0.1);
    font-size: 13px;
    line-height: 1.6;
}
#messages div {
    margin-bottom: 5px;
    padding: 4px 8px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 4px;
}
#messages div:last-child {
    margin-bottom: 0;
}
#input {
    flex: 0 0 200px;
    padding: 8px 12px;
    border: 2px solid rgba(255, 255, 255, 0.3);
    border-radius: 6px;
    font-size: 14px;
    background: rgba(255, 255, 255, 0.9);
    color: #333;
}
.status {
    text-align: center;
    padding: 10px;
    margin-bottom: 15px;
    background: rgba(76, 175, 80, 0.2);
    border-radius: 6px;
    font-weight: 600;
}
.status.disconnected {
    background: rgba(244, 67, 54, 0.2);
}
</style>
</head>
<body>
<div class="container">
    <h2>üéØ –ö–æ–æ–ø–µ—Ä–∞—Ç–∏–≤–Ω–∞—è –ì–æ–ª–æ–≤–æ–ª–æ–º–∫–∞ - –£—Ä–æ–≤–µ–Ω—å 1</h2>
    <div id="status" class="status disconnected">–û—Ç–∫–ª—é—á–µ–Ω–æ</div>
    
    <div class="controls">
        <label>–ö–æ–º–Ω–∞—Ç–∞:</label>
        <input id="room" type="text" value="room1" placeholder="room1">
        <label>–ò–º—è:</label>
        <input id="name" type="text" value="player1" placeholder="player1">
        <button id="connectBtn" class="secondary">–ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è</button>
        <button id="addBox" disabled>‚ûï –ö—É–±</button>
        <button id="addCircle" disabled>‚ö™ –®–∞—Ä</button>
        <button id="addLever" disabled>‚öñÔ∏è –†—ã—á–∞–≥</button>
    </div>

    <canvas id="game" width="800" height="600"></canvas>

    <div id="chat">
        <div id="messages"></div>
        <input id="input" type="text" placeholder="–í–≤–µ–¥–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ..." disabled>
        <button id="send" disabled>–û—Ç–ø—Ä–∞–≤–∏—Ç—å</button>
    </div>
</div>

<script>
const canvas = document.getElementById('game');
const engine = Matter.Engine.create();
const world = engine.world;
const render = Matter.Render.create({
    canvas,
    engine,
    options: { 
        width: 800, 
        height: 600, 
        wireframes: false, 
        background: '#f0f0f0',
        showAngleIndicator: false,
        showVelocity: false
    }
});

Matter.Engine.run(engine);
Matter.Render.run(render);

let ws = null;
let playerName = '';
let roomName = '';
const objects = new Map();
let currentDragId = null;
let isConnected = false;

// –ü–ª–∞—Ç—Ñ–æ—Ä–º–∞ (–ø–æ–ª)
const ground = Matter.Bodies.rectangle(400, 590, 810, 20, { 
    isStatic: true,
    render: { fillStyle: '#8B4513' }
});
Matter.World.add(world, ground);

// –¶–µ–ª–µ–≤–∞—è –∫–Ω–æ–ø–∫–∞ (–æ—Ä–∞–Ω–∂–µ–≤–∞—è)
const targetButton = Matter.Bodies.circle(720, 550, 25, { 
    isStatic: true, 
    render: { 
        fillStyle: "#f97316",
        strokeStyle: "#c2410c",
        lineWidth: 3
    }
});
Matter.World.add(world, targetButton);

// –í–∏–∑—É–∞–ª—å–Ω–∞—è –º–µ—Ç–∫–∞ —Ü–µ–ª–∏
const targetLabel = Matter.Bodies.rectangle(720, 520, 60, 20, {
    isStatic: true,
    isSensor: true,
    render: { 
        fillStyle: "rgba(249, 115, 22, 0.3)",
        strokeStyle: "#f97316",
        lineWidth: 2
    }
});
Matter.World.add(world, targetLabel);

function addMessage(msg, isSystem = false) {
    const m = document.getElementById("messages");
    const div = document.createElement("div");
    div.textContent = msg;
    if (isSystem) {
        div.style.fontWeight = 'bold';
        div.style.color = '#4CAF50';
    }
    m.appendChild(div);
    m.scrollTop = m.scrollHeight;
}

function updateStatus(connected) {
    isConnected = connected;
    const statusEl = document.getElementById('status');
    const connectBtn = document.getElementById('connectBtn');
    const addBox = document.getElementById('addBox');
    const addCircle = document.getElementById('addCircle');
    const addLever = document.getElementById('addLever');
    const input = document.getElementById('input');
    const send = document.getElementById('send');
    
    if (connected) {
        statusEl.textContent = `‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω–æ: ${roomName} | –ò–≥—Ä–æ–∫: ${playerName}`;
        statusEl.className = 'status';
        connectBtn.textContent = '–û—Ç–∫–ª—é—á–∏—Ç—å—Å—è';
        addBox.disabled = false;
        addCircle.disabled = false;
        addLever.disabled = false;
        input.disabled = false;
        send.disabled = false;
    } else {
        statusEl.textContent = '‚ùå –û—Ç–∫–ª—é—á–µ–Ω–æ';
        statusEl.className = 'status disconnected';
        connectBtn.textContent = '–ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è';
        addBox.disabled = true;
        addCircle.disabled = true;
        addLever.disabled = true;
        input.disabled = true;
        send.disabled = true;
    }
}

// WebSocket —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
function connectWS() {
    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.close();
        return;
    }
    
    ws = new WebSocket(`ws://localhost:8000/ws/${roomName}/${playerName}`);
    
    ws.onopen = () => {
        updateStatus(true);
        addMessage(`‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω–æ –∫ –∫–æ–º–Ω–∞—Ç–µ "${roomName}"`, true);
    };
    
    ws.onclose = () => {
        updateStatus(false);
        addMessage('‚ùå –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∑–∞–∫—Ä—ã—Ç–æ', true);
    };
    
    ws.onerror = (error) => {
        addMessage('‚ùå –û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —Å–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω!', true);
        console.error('WebSocket error:', error);
    };
    
    ws.onmessage = (e) => {
        try {
            const msg = JSON.parse(e.data);
            
            if (msg.type === "init") {
                // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è: –∑–∞–≥—Ä—É–∂–∞–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –æ–±—ä–µ–∫—Ç—ã –∏ –∏—Å—Ç–æ—Ä–∏—é —á–∞—Ç–∞
                msg.objects?.forEach(o => spawnObject(o, true));
                msg.chat?.forEach(c => addMessage(`${c.player}: ${c.message}`));
                addMessage(`üì¶ –ó–∞–≥—Ä—É–∂–µ–Ω–æ ${msg.objects?.length || 0} –æ–±—ä–µ–∫—Ç–æ–≤`, true);
            }
            else if (msg.type === "spawn") {
                spawnObject(msg, true);
                if (!msg.isRemote) {
                    addMessage(`‚ûï ${msg.player || '–ö—Ç–æ-—Ç–æ'} –¥–æ–±–∞–≤–∏–ª ${getTypeName(msg.type)}`, true);
                }
            }
            else if (msg.type === "update") {
                updateObject(msg, true);
            }
            else if (msg.type === "remove") {
                removeObject(msg, true);
                addMessage(`üóëÔ∏è ${msg.player || '–ö—Ç–æ-—Ç–æ'} —É–¥–∞–ª–∏–ª –æ–±—ä–µ–∫—Ç`, true);
            }
            else if (msg.type === "chat") {
                addMessage(`${msg.player}: ${msg.message}`);
            }
        } catch (err) {
            console.error('Error parsing message:', err);
        }
    };
}

function getTypeName(type) {
    const names = {
        'box': '–∫—É–±',
        'circle': '—à–∞—Ä',
        'lever': '—Ä—ã—á–∞–≥'
    };
    return names[type] || type;
}

document.getElementById('connectBtn').onclick = () => {
    roomName = document.getElementById('room').value.trim();
    playerName = document.getElementById('name').value.trim();
    
    if (!roomName || !playerName) {
        alert('–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –∫–æ–º–Ω–∞—Ç—ã –∏ –∏–º—è –∏–≥—Ä–æ–∫–∞!');
        return;
    }
    
    if (isConnected) {
        ws?.close();
    } else {
        connectWS();
    }
};

// –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –æ–±—ä–µ–∫—Ç–æ–≤
function registerObject(id, type, body) {
    objects.set(id, { type, body });
    body.plugin = { id };
}

// –°–æ–∑–¥–∞–Ω–∏–µ –æ–±—ä–µ–∫—Ç–æ–≤
function spawnObject(data, isRemote = false) {
    const { 
        id = crypto.randomUUID(), 
        type, 
        x, 
        y, 
        w = 60, 
        h = 60, 
        r = 20, 
        length = 100 
    } = data;
    
    let body;
    let color = '#3498db';
    
    if (type === "box") {
        body = Matter.Bodies.rectangle(x, y, w, h, { 
            restitution: 0.3, 
            friction: 0.2,
            render: { fillStyle: color }
        });
    }
    else if (type === "circle") {
        body = Matter.Bodies.circle(x, y, r, { 
            restitution: 0.5, 
            friction: 0.1,
            render: { fillStyle: color }
        });
    }
    else if (type === "lever") {
        body = Matter.Bodies.rectangle(x, y, length, 20, { 
            restitution: 0.2, 
            density: 0.002,
            render: { fillStyle: '#9b59b6' }
        });
        
        const pivot = Matter.Constraint.create({ 
            pointA: { x, y }, 
            bodyB: body, 
            pointB: { x: 0, y: 0 }, 
            stiffness: 1,
            render: { strokeStyle: '#7d3c98', lineWidth: 2 }
        });
        
        Matter.World.add(world, pivot);
    }
    
    if (body) {
        Matter.World.add(world, body);
        registerObject(id, type, body);
        
        if (!isRemote && ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({
                ...data,
                type: "spawn",
                id,
                player: playerName
            }));
        }
    }
}

// –ò–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏—è –¥–ª—è –ø–ª–∞–≤–Ω–æ–≥–æ –¥–≤–∏–∂–µ–Ω–∏—è
const interpolationFactor = 0.3; // –°–∫–æ—Ä–æ—Å—Ç—å –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏–∏ (0-1)

function updateObject(data, isRemote = false) {
    const obj = objects.get(data.id);
    if (obj && isRemote) {
        const targetX = data.x;
        const targetY = data.y;
        const currentX = obj.body.position.x;
        const currentY = obj.body.position.y;
        
        // –ü–ª–∞–≤–Ω–∞—è –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏—è –≤–º–µ—Å—Ç–æ –º–≥–Ω–æ–≤–µ–Ω–Ω–æ–≥–æ —Å–∫–∞—á–∫–∞
        const newX = currentX * (1 - interpolationFactor) + targetX * interpolationFactor;
        const newY = currentY * (1 - interpolationFactor) + targetY * interpolationFactor;
        
        Matter.Body.setPosition(obj.body, { x: newX, y: newY });
        
        if (data.angle !== undefined) {
            const currentAngle = obj.body.angle;
            const targetAngle = data.angle;
            // –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è —É–≥–ª–∞ –¥–ª—è –ø–ª–∞–≤–Ω–æ–≥–æ –ø–æ–≤–æ—Ä–æ—Ç–∞
            let angleDiff = targetAngle - currentAngle;
            if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
            if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
            const newAngle = currentAngle + angleDiff * interpolationFactor;
            Matter.Body.setAngle(obj.body, newAngle);
        }
    }
}

function removeObject(data, isRemote = false) {
    const obj = objects.get(data.id);
    if (obj) {
        Matter.World.remove(world, obj.body);
        objects.delete(data.id);
        
        if (!isRemote && ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({
                type: "remove",
                id: data.id,
                player: playerName
            }));
        }
    }
}

// –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –æ–±—ä–µ–∫—Ç–æ–≤ –∫–Ω–æ–ø–∫–∞–º–∏
document.getElementById('addBox').onclick = () => {
    spawnObject({
        type: "box",
        x: Math.random() * 700 + 50,
        y: 50,
        w: 60,
        h: 60
    });
};

document.getElementById('addCircle').onclick = () => {
    spawnObject({
        type: "circle",
        x: Math.random() * 700 + 50,
        y: 50,
        r: 20
    });
};

document.getElementById('addLever').onclick = () => {
    spawnObject({
        type: "lever",
        x: Math.random() * 700 + 50,
        y: Math.random() * 300 + 50,
        length: 100
    });
};

// Drag & Drop
const mouse = Matter.Mouse.create(canvas);
const mouseConstraint = Matter.MouseConstraint.create(engine, { 
    mouse,
    constraint: {
        stiffness: 0.9,
        render: { visible: false }
    }
});
Matter.World.add(world, mouseConstraint);

Matter.Events.on(mouseConstraint, "startdrag", (e) => {
    currentDragId = e.body.plugin?.id;
});

Matter.Events.on(mouseConstraint, "enddrag", () => {
    currentDragId = null;
});

// Throttle update –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏
function sendUpdate(obj, id) {
    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
            type: "update",
            id,
            x: obj.position.x,
            y: obj.position.y,
            angle: obj.angle,
            player: playerName
        }));
    }
}

const sendUpdateThrottled = throttle(sendUpdate, 50);

function throttle(fn, ms) {
    let last = 0;
    return (...args) => {
        const now = Date.now();
        if (now - last > ms) {
            last = now;
            fn(...args);
        }
    };
}

Matter.Events.on(engine, "afterUpdate", () => {
    if (!currentDragId) return;
    const obj = objects.get(currentDragId);
    if (obj) {
        sendUpdateThrottled(obj.body, currentDragId);
    }
});

// –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è —Ü–µ–ª–∏
let goalAchieved = false;
Matter.Events.on(engine, "collisionStart", (event) => {
    if (goalAchieved) return;
    
    event.pairs.forEach(pair => {
        const { bodyA, bodyB } = pair;
        if ((bodyA === targetButton || bodyB === targetButton) && 
            (bodyA === targetButton ? bodyB : bodyA).plugin?.id) {
            goalAchieved = true;
            addMessage("üéâ –¶–ï–ü–û–ß–ö–ê –°–†–ê–ë–û–¢–ê–õ–ê! –û–¢–õ–ò–ß–ù–ê–Ø –†–ê–ë–û–¢–ê! üéâ", true);
            
            // –í–∏–∑—É–∞–ª—å–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç
            targetButton.render.fillStyle = "#10b981";
            Matter.Render.setPixelRatio(render, 1);
            
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: "chat",
                    message: "üéâ –¶–µ–ø–æ—á–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞! –£—Ä–æ–≤–µ–Ω—å –ø—Ä–æ–π–¥–µ–Ω!",
                    player: "–°–∏—Å—Ç–µ–º–∞"
                }));
            }
        }
    });
});

// –ß–∞—Ç
document.getElementById("send").onclick = () => {
    const input = document.getElementById("input");
    const msg = input.value.trim();
    if (ws && ws.readyState === WebSocket.OPEN && msg) {
        ws.send(JSON.stringify({
            type: "chat",
            message: msg,
            player: playerName
        }));
        addMessage(`–í—ã: ${msg}`);
        input.value = "";
    }
};

document.getElementById("input").addEventListener("keypress", (e) => {
    if (e.key === "Enter") {
        document.getElementById("send").click();
    }
});

// –ì–æ—Ç–æ–≤—ã–π —Å—Ç–∞—Ä—Ç–æ–≤—ã–π —É—Ä–æ–≤–µ–Ω—å
function setupLevel() {
    // –ü–ª–∞—Ç—Ñ–æ—Ä–º—ã –¥–ª—è –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ —Ü–µ–ø–æ—á–∫–∏
    spawnObject({
        type: "box",
        x: 400,
        y: 500,
        w: 200,
        h: 20,
        id: "platform1"
    }, true);
    
    spawnObject({
        type: "box",
        x: 600,
        y: 400,
        w: 200,
        h: 20,
        id: "platform2"
    }, true);
    
    // –°—Ç–∞—Ä—Ç–æ–≤—ã–π —à–∞—Ä (—É–∂–µ –Ω–∞ —Å—Ü–µ–Ω–µ)
    spawnObject({
        type: "circle",
        x: 100,
        y: 50,
        r: 20,
        id: "startBall"
    }, true);
    
    // –†—ã—á–∞–≥–∏ –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–Ω–æ–≥–æ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
    spawnObject({
        type: "lever",
        x: 350,
        y: 480,
        length: 100,
        id: "lever1"
    }, true);
    
    spawnObject({
        type: "lever",
        x: 580,
        y: 380,
        length: 100,
        id: "lever2"
    }, true);
    
    addMessage("üéÆ –£—Ä–æ–≤–µ–Ω—å –∑–∞–≥—Ä—É–∂–µ–Ω! –°–æ–≤–º–µ—Å—Ç–Ω–æ –∑–∞–≤–µ—Ä—à–∏—Ç–µ —Ü–µ–ø–æ—á–∫—É!", true);
    addMessage("üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞: –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ä—ã—á–∞–≥–∏ –∏ –¥–æ–±–∞–≤–ª—è–π—Ç–µ –æ–±—ä–µ–∫—Ç—ã –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –ø—É—Ç–∏ —à–∞—Ä–∞ –∫ –æ—Ä–∞–Ω–∂–µ–≤–æ–π –∫–Ω–æ–ø–∫–µ", true);
}

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —É—Ä–æ–≤–Ω—è –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
setupLevel();

// –û—á–∏—Å—Ç–∫–∞ –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
window.addEventListener('beforeunload', () => {
    if (ws) {
        ws.close();
    }
});
</script>
</body>
</html>

