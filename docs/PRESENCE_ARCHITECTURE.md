# Архитектура системы Presence (статус онлайн/оффлайн)

## Обзор
Данный документ описывает новую архитектуру системы Presence в приложении, которая была переработана с модели 'single node' на 'per-connection' модель. Это решает проблему 'false offline' при использовании приложения в нескольких вкладках или на нескольких устройствах.

## Старая архитектура (проблема)
Ранее статус пользователя хранился в одной ноде Realtime Database по пути `status/{userId}`. При закрытии любой из вкладок пользователя, `onDisconnect` устанавливал статус 'offline', что приводило к некорректному отображению, если другие вкладки оставались открытыми.

## Новая архитектура (per-connection model)

### Принцип работы
Теперь для каждого активного соединения пользователя (каждая вкладка, каждое устройство) генерируется уникальный `connectionId`. Эти `connectionId` хранятся по пути `connections/{userId}/{connectionId}`.

1.  **При подключении (goOnline):**
    *   Генерируется уникальный `connectionId`.
    *   Запись `connections/{userId}/{connectionId} = { online: true, connectedAt: serverTimestamp() }` создается в Realtime Database.
    *   `onDisconnect()` устанавливается для *этого конкретного* `connectionId`, чтобы удалить его при разрыве соединения.
    *   Запускается мониторинг `.info/connected` для отслеживания состояния сетевого подключения Firebase. При восстановлении соединения `onDisconnect` для текущего `connectionId` переустанавливается, чтобы гарантировать его удаление при следующем разрыве.
    *   Вызывается `updateAggregatedStatus` для обновления общего статуса пользователя.

2.  **Агрегированный статус (status/{userId}):**
    *   Общий статус пользователя (`status/{userId}`) теперь вычисляется на основе количества активных `connectionId` в `connections/{userId}`.
    *   Если `connections/{userId}` содержит хотя бы один `connectionId`, статус пользователя считается 'online'. В противном случае — 'offline'.
    *   Эта агрегация происходит при каждом изменении `connections/{userId}` (т.е. при подключении/отключении вкладки/устройства).
    *   Поле `activeConnections` в `status/{userId}` показывает текущее количество активных соединений.

3.  **При отключении (goOffline):**
    *   Конкретный `connectionId` удаляется из `connections/{userId}`.
    *   `onDisconnect` очищается, а подписка на `.info/connected` отменяется.
    *   Вызывается `updateAggregatedStatus` для актуализации общего статуса пользователя.

### Структура данных в Realtime Database

```
/connections
  /{userId}
    /{connId1}: { online: true, connectedAt: timestamp }
    /{connId2}: { online: true, connectedAt: timestamp }
/status
  /{userId}: { state: 'online' | 'offline', lastChanged: timestamp, activeConnections: number }
```

### Преимущества
-   **Корректный статус при multi-tab/multi-device:** Пользователь остается онлайн, пока хотя бы одна вкладка/устройство активно.
-   **Устойчивость к сбоям:** Механизм `onDisconnect` Firebase надежно удаляет соединение при обрыве связи.
-   **Явное управление:** Каждый клиент управляет только своим собственным `connectionId`.

### Риски и ограничения
-   Увеличенное количество записей в Realtime Database (по одной на каждое соединение). Это управляется автоматически, но стоит учитывать для очень крупных приложений.
-   Зависимость от корректной работы `onDisconnect` и `.info/connected`.

### Дальнейшее развитие
-   Добавление информации о устройстве/браузере в данные `connectionId` для более детального анализа.
-   Реализация 'idle' статуса, если нет активности в течение определенного времени, даже при активном соединении.
