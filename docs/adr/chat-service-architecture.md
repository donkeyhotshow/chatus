# ADR: Архитектура ChatService

## Контекст
- Требуется единый API для чата, холста и игр.
- Необходимо контролировать нагрузку (rate limiting, flood mute).
- Firebase (Firestore/Auth/Storage) используется как backend в real-time режиме.
- Требование: предсказуемость и отказоустойчивость (стабильность выше скорости).

## Решение
- **Singleton per roomId**: один экземпляр `ChatService` на комнату, кэшируется в `getChatService`.
- **Централизованные слушатели**: подписки на room/games/messages создаются один раз при инициализации.
- **Пагинация и rate limiting**: батч 30 сообщений, cooldown 500 мс, auto-mute при флуде.
- **Строгие типы**: все сущности определены в `src/lib/types.ts`.
- **Error pipeline**: `logger` + `errorEmitter` + `FirestorePermissionError`.
- **Separation of concerns**: компоненты работают через `useChatService`, без прямого доступа к Firebase.

## Последствия
### Плюсы
- Предсказуемая нагрузка на Firestore.
- Единая точка входа для чата, холста и игр.
- Легче тестировать: можно мокать/эмулировать Firebase на уровне сервиса.
### Минусы
- Необходим контроль за жизненным циклом singleton при выходе из комнаты.
- Миграция требовала обновления компонентов на новый API.

## Альтернативы
- Множественные сервисы на компонент: выше расход подписок, непредсказуемость.
- Прямые вызовы Firebase из компонентов: сложнее контролировать ошибки и нагрузку.

## Статус
Принято.

