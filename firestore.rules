
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Rate limiting collection
    match /rateLimits/{userId} {
      allow read, write: if request.auth.uid == userId;
    }
    
    match /rooms/{roomId} {
      // Restrict read access: only participants or explicitly public rooms may be read.
      // Removed temporary global authenticated read to reduce data exposure.
      function isParticipant() {
        return request.auth.uid in resource.data.participants;
      }
      // Allow read only for participants or explicitly public rooms
      allow read: if isParticipant() || (resource.data.public == true);

      allow create: if request.resource.data.participants.size() == 1 &&
                        request.resource.data.participantProfiles.size() == 1 &&
                        request.auth.uid == request.resource.data.participants[0] &&
                        request.auth.uid == request.resource.data.participantProfiles[0].id &&
                        request.resource.data.participants.size() == 1;
      
      allow update: if request.auth.uid in resource.data.participants;

      // Allow a user to add themself to participants (join) by performing an update
      // that only appends the current auth.uid to participants and participantProfiles.
      // This allows clients to self-join without a separate server function.
      // Limit rooms to maximum 2 participants for 1-on-1 chat
      allow update: if request.auth.uid != null &&
                    // Only participants/participantProfiles may change
                    request.resource.data.diff(resource.data).affectedKeys().hasOnly(['participants', 'participantProfiles']) &&
                    // Ensure room doesn't exceed 2 participants
                    request.resource.data.participants.size() <= 2 &&
                    (
                      // Join: append self (only if room has less than 2 participants)
                      (
                        request.resource.data.participants.hasAll(resource.data.participants) &&
                        request.resource.data.participants.size() == resource.data.participants.size() + 1 &&
                        request.auth.uid in request.resource.data.participants &&
                        request.resource.data.participantProfiles.size() >= resource.data.participantProfiles.size() &&
                        // Room must have less than 2 participants before joining
                        resource.data.participants.size() < 2
                      )
                      ||
                      // Leave: remove only self (no other removals)
                      (
                        // new participants is a strict subset of old
                        resource.data.participants.hasAll(request.resource.data.participants) &&
                        request.resource.data.participants.size() == resource.data.participants.size() - 1 &&
                        request.auth.uid in resource.data.participants &&
                        !(request.auth.uid in request.resource.data.participants) &&
                        // participantProfiles reduced by one as well
                        request.resource.data.participantProfiles.size() == resource.data.participantProfiles.size() - 1
                      )
                    );

      match /messages/{messageId} {
        // Allow read if user is a participant in the room
        allow read: if request.auth.uid in get(/databases/$(database)/documents/rooms/$(roomId)).data.participants;

        // Allow create if user is authenticated and a participant in the room
        allow create: if request.auth.uid != null &&
                          request.auth.uid in get(/databases/$(database)/documents/rooms/$(roomId)).data.participants &&
                          request.auth.uid == request.resource.data.senderId &&
                          // Prevent client-side timestamp forging - require server timestamp equality
                          request.resource.data.createdAt == request.time &&
                          // Ensure basic required keys exist (text or image or type)
                          (request.resource.data.keys().hasAny(['text']) || request.resource.data.keys().hasAny(['imageUrl']) || request.resource.data.keys().hasAny(['type'])) &&
                          // Validate text length
                          (!(request.resource.data.keys().hasAny(['text'])) || (request.resource.data.text is string && request.resource.data.text.size() <= 2000)) &&
                          // Limit reactions size if provided
                          (!(request.resource.data.keys().hasAny(['reactions'])) || request.resource.data.reactions.size() <= 50) &&
                          // Optional rate-limit guard: allow if no rateLimits doc exists OR lastMessage older than 1s
                          (
                            !exists(/databases/$(database)/documents/rateLimits/$(request.auth.uid)) ||
                            (request.time - get(/databases/$(database)/documents/rateLimits/$(request.auth.uid)).data.lastMessage > duration.value(1, 's'))
                          );

        allow delete: if request.auth.uid == resource.data.senderId;

        // Allow update only for reactions, delivered, seen (sender cannot change delivered/seen)
        allow update: if request.auth.uid in get(/databases/$(database)/documents/rooms/$(roomId)).data.participants &&
                      request.resource.data.diff(resource.data).affectedKeys().hasOnly(['reactions', 'delivered', 'seen']) &&
                      // Limit reactions array size to prevent DoS attacks
                      (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['reactions']) 
                       || request.resource.data.reactions.size() <= 50) &&
                      // Sender cannot modify delivered/seen fields
                      (request.auth.uid != resource.data.senderId ||
                       !request.resource.data.diff(resource.data).affectedKeys().hasAny(['delivered', 'seen']));
        
        // Additional validation helpers for creates/updates
        function isValidMessageCreate() {
          return request.resource.data.keys().hasOnly(['text','imageUrl','type','senderId','clientMessageId','createdAt','reactions','delivered','seen','user']) &&
                 // text if present must be string and length <= 2000
                 (
                   !request.resource.data.keys().hasAny(['text']) ||
                   (request.resource.data.text is string && request.resource.data.text.size() <= 2000)
                 ) &&
                 // senderId must match authenticated user
                 (request.resource.data.senderId == request.auth.uid) &&
                 // createdAt must be server timestamp (enforced above) and user object if provided must contain id
                 (
                   !request.resource.data.keys().hasAny(['user']) ||
                   (request.resource.data.user.id is string)
                 );
        }
      }

      match /canvasSheets/{sheetId} {
        function isParticipant() {
          return request.auth.uid in get(/databases/$(database)/documents/rooms/$(roomId)).data.participants;
        }
        
        // Add data validation
        allow create: if isParticipant() && 
                         request.resource.data.keys().hasAll(['name', 'createdAt']) &&
                         request.resource.data.name is string &&
                         request.resource.data.name.size() > 0 &&
                         request.resource.data.name.size() <= 100;
        
        allow read: if isParticipant();
        allow delete: if false;
      }
      
      match /canvasPaths/{pathId} {
        function isParticipant() {
          return request.auth.uid in get(/databases/$(database)/documents/rooms/$(roomId)).data.participants;
        }
        
        // Add data validation for canvas paths
        allow create: if isParticipant() &&
                         request.resource.data.keys().hasAll(['sheetId', 'user', 'points', 'color']) &&
                         request.resource.data.points is list &&
                         request.resource.data.points.size() > 0 &&
                         request.resource.data.points.size() <= 10000;
        
        allow read: if isParticipant();
        allow delete: if isParticipant();
      }
      
      match /games/{gameId} {
        function isParticipant() {
          return request.auth.uid in get(/databases/$(database)/documents/rooms/$(roomId)).data.participants;
        }
        
        // Allow flexible game state updates - only require type field on creation
        allow create: if isParticipant() &&
                         request.resource.data.keys().hasAll(['type']) &&
                         request.resource.data.type is string;
        
        allow read: if isParticipant();
        allow update: if isParticipant();
        allow delete: if isParticipant();
      }
    }

    match /users/{userId} {
        allow create: if request.auth.uid == userId;
        // Allow read only for public profiles or the profile owner
        allow read: if resource.data.public == true || request.auth.uid == userId;
        allow update: if request.auth.uid == userId;
    }
    
    // Presence documents (if presence stored in Firestore)
    match /status/{userId} {
      // Only the user may write their status document
      allow write: if request.auth.uid == userId &&
                   request.resource.data.keys().hasAll(['state','lastChanged','activeConnections']) &&
                   request.resource.data.state is string &&
                   (request.resource.data.state == 'online' || request.resource.data.state == 'offline') &&
                   request.resource.data.activeConnections is number &&
                   request.resource.data.activeConnections >= 0 &&
                   request.resource.data.activeConnections <= 1000;
      // Allow read for authenticated users (presence is public)
      allow read: if request.auth.uid != null;
    }

    match /connections/{userId}/{connId} {
      // Only owner may create/delete their connection entries
      allow create: if request.auth.uid == userId &&
                     request.resource.data.keys().hasAll(['online','connectedAt']) &&
                     request.resource.data.online is bool;
      allow delete: if request.auth.uid == userId;
      // Allow read for authenticated users (optional)
      allow read: if request.auth.uid != null;
    }
  }
}
