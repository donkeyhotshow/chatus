<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <title>Coop Towerense Online</title>
    <style>
        body {
            margin: 0;
            background: #111;
            color: #fff;
            font-family: monospace;
            display: flex;
        }

        #ui {
            width: 280px;
            padding: 10px;
            background: #1c1c1c;
            overflow-y: auto;
        }

        button {
            width: 100%;
            margin: 4px 0;
            padding: 8px;
            background: #222;
            color: #fff;
            border: 1px solid #444;
            cursor: pointer;
        }

        button:hover {
            background: #333;
        }

        button.selected {
            background: #0a84ff;
        }

        canvas {
            background: #000;
            cursor: crosshair;
        }

        .player-info {
            background: #333;
            padding: 8px;
            margin: 4px 0;
            border-radius: 4px;
        }

        .tower-info {
            background: #2a2a2a;
            padding: 6px;
            margin: 2px 0;
            border-radius: 3px;
            font-size: 12px;
        }

        .leaderboard {
            margin-top: 10px;
        }

        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            padding: 4px;
            background: #2a2a2a;
            margin: 2px 0;
            border-radius: 3px;
        }

        .upgrade-panel {
            background: #444;
            padding: 8px;
            margin: 8px 0;
            border-radius: 4px;
            display: none;
        }

        .upgrade-panel.active {
            display: block;
        }
    </style>
</head>

<body>
    <div id="ui">
        <h3>üè∞ Online Tower Defense</h3>

        <div class="player-info">
            <div>üë§ Player: <span id="playerId"></span></div>
            <div>üèÜ Score: <span id="playerScore">0</span></div>
            <div>üèóÔ∏è Towers: <span id="playerTowers">0</span></div>
        </div>

        <div>üí∞ Gold: <span id="gold"></span></div>
        <div>‚ù§Ô∏è Base: <span id="base"></span></div>
        <div>üåä Wave: <span id="wave"></span></div>

        <hr>

        <h4>Build Towers:</h4>
        <button id="basic-btn" class="selected" onclick="selectTower('BASIC')">‚ö° Basic (25üí∞)</button>
        <button id="fast-btn" onclick="selectTower('FAST')">üöÄ Fast (40üí∞)</button>
        <button id="heavy-btn" onclick="selectTower('HEAVY')">üí™ Heavy (60üí∞)</button>

        <div class="upgrade-panel" id="upgradePanel">
            <h4>üîß Upgrade Tower</h4>
            <div id="towerStats"></div>
            <button id="upgradeBtn" onclick="upgradeTower()">‚¨ÜÔ∏è Upgrade</button>
            <button onclick="deselectTower()">‚ùå Deselect</button>
        </div>

        <hr>

        <button onclick="startWave()">‚ñ∂Ô∏è Start Wave</button>
        <button onclick="sellTower()" id="sellBtn" style="display:none; background:#cc3333;">üí∏ Sell Tower</button>

        <div class="leaderboard">
            <h4>üèÜ Leaderboard</h4>
            <div id="leaderboardList"></div>
        </div>

        <div>
            <h4>üèóÔ∏è Your Towers</h4>
            <div id="playerTowersList"></div>
        </div>

        <div style="margin-top: 20px; font-size: 11px; color: #888;">
            <div>üí° Left click: Build/Select tower</div>
            <div>üí° Right click: Quick upgrade</div>
            <div>üí° Only upgrade your own towers</div>
        </div>
    </div>

    <canvas id="game" width="800" height="600"></canvas>

    <!-- FIREBASE -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js"></script>

    <script>
        /* ================= FIREBASE CONFIG ================= */
        const firebaseConfig = {
            apiKey: "AIzaSyDemo-ReplaceWithYourKey",
            authDomain: "your-project.firebaseapp.com",
            databaseURL: "https://your-project-default-rtdb.firebaseio.com/",
            projectId: "your-project-id",
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const db = firebase.database();
        const ROOM = "room1";

        /* ================= PLAYER SYSTEM ================= */
        const PLAYER_ID = 'player_' + Math.random().toString(36).slice(2, 8);
        let playerData = {
            id: PLAYER_ID,
            name: PLAYER_ID.slice(-4),
            score: 0,
            towersBuilt: 0,
            joinedAt: Date.now()
        };

        /* ================= GAME CONFIG ================= */
        const CELL = 40;
        const GRID_WIDTH = 20;
        const GRID_HEIGHT = 15;
        const pathsY = [3, 7, 11]; // 3 lanes

        const TOWERS = {
            BASIC: { cost: 25, range: 120, damage: 10, rate: 1, color: '#00d4ff', upgradeCost: 20 },
            FAST: { cost: 40, range: 100, damage: 8, rate: 2, color: '#a855f7', upgradeCost: 32 },
            HEAVY: { cost: 60, range: 160, damage: 25, rate: 0.5, color: '#f59e0b', upgradeCost: 48 }
        };

        const ENEMIES = {
            BASIC: { hp: 50, speed: 25, value: 5, color: '#dc143c' },
            FAST: { hp: 30, speed: 40, value: 8, color: '#ff8c00' },
            TANK: { hp: 150, speed: 15, value: 15, color: '#8b0000' }
        };

        /* ================= STATE ================= */
        let selectedTowerType = 'BASIC';
        let selectedTowerId = null;
        let towers = {};
        let enemies = {};
        let players = {};
        let state = { gold: 100, baseHP: 20, wave: 0, waveActive: false };

        /* ================= FIREBASE LISTENERS ================= */
        const stateRef = db.ref(`${ROOM}/state`);
        const towersRef = db.ref(`${ROOM}/towers`);
        const enemiesRef = db.ref(`${ROOM}/enemies`);
        const playersRef = db.ref(`${ROOM}/players`);

        // Initialize room if doesn't exist
        stateRef.once('value').then(snapshot => {
            if (!snapshot.exists()) {
                stateRef.set(state);
            }
        });

        // Register player
        playersRef.child(PLAYER_ID).set(playerData);
        playersRef.child(PLAYER_ID).onDisconnect().remove();

        // State listeners
        stateRef.on('value', snapshot => {
            if (snapshot.exists()) {
                state = snapshot.val();
                updateUI();
            }
        });

        towersRef.on('value', snapshot => {
            towers = snapshot.val() || {};
            updatePlayerTowersList();
        });

        enemiesRef.on('value', snapshot => {
            enemies = snapshot.val() || {};
        });

        playersRef.on('value', snapshot => {
            players = snapshot.val() || {};
            updateLeaderboard();
        });

        /* ================= UI FUNCTIONS ================= */
        function updateUI() {
            document.getElementById('playerId').textContent = playerData.name;
            document.getElementById('playerScore').textContent = playerData.score;
            document.getElementById('playerTowers').textContent = playerData.towersBuilt;
            document.getElementById('gold').textContent = state.gold;
            document.getElementById('base').textContent = state.baseHP;
            document.getElementById('wave').textContent = state.wave;
        }

        function updateLeaderboard() {
            const entries = Object.values(players)
                .sort((a, b) => b.score - a.score)
                .slice(0, 5);

            const html = entries.map((player, index) =>
                `<div class="leaderboard-entry">
                    <span>${index + 1}. ${player.name}</span>
                    <span>${player.score}</span>
                </div>`
            ).join('');

            document.getElementById('leaderboardList').innerHTML = html;
        }

        function updatePlayerTowersList() {
            const myTowers = Object.entries(towers)
                .filter(([id, tower]) => tower.owner === PLAYER_ID)
                .map(([id, tower]) =>
                    `<div class="tower-info" onclick="selectTowerById('${id}')">
                        ${tower.type} Lv.${tower.level} (${tower.kills || 0} kills)
                    </div>`
                ).join('');

            document.getElementById('playerTowersList').innerHTML = myTowers || '<div style="color:#888;">No towers built</div>';
        }

        function selectTower(type) {
            selectedTowerType = type;
            document.querySelectorAll('#ui button').forEach(btn => btn.classList.remove('selected'));
            document.getElementById(type.toLowerCase() + '-btn').classList.add('selected');
            deselectTower();
        }

        function selectTowerById(towerId) {
            const tower = towers[towerId];
            if (!tower || tower.owner !== PLAYER_ID) return;

            selectedTowerId = towerId;
            showUpgradePanel(tower);
        }

        function showUpgradePanel(tower) {
            const panel = document.getElementById('upgradePanel');
            const stats = document.getElementById('towerStats');
            const upgradeBtn = document.getElementById('upgradeBtn');
            const sellBtn = document.getElementById('sellBtn');

            const upgradeCost = Math.floor(TOWERS[tower.type].upgradeCost * Math.pow(1.5, tower.level - 1));

            stats.innerHTML = `
                <div>Type: ${tower.type}</div>
                <div>Level: ${tower.level}</div>
                <div>Damage: ${Math.floor(tower.damage)}</div>
                <div>Range: ${Math.floor(tower.range)}</div>
                <div>Fire Rate: ${tower.rate.toFixed(1)}/s</div>
                <div>Kills: ${tower.kills || 0}</div>
                <div>Upgrade Cost: ${upgradeCost}üí∞</div>
            `;

            upgradeBtn.disabled = state.gold < upgradeCost;
            upgradeBtn.textContent = `‚¨ÜÔ∏è Upgrade (${upgradeCost}üí∞)`;

            panel.classList.add('active');
            sellBtn.style.display = 'block';
        }

        function deselectTower() {
            selectedTowerId = null;
            document.getElementById('upgradePanel').classList.remove('active');
            document.getElementById('sellBtn').style.display = 'none';
        }

        /* ================= TOWER FUNCTIONS ================= */
        function buildTower(x, y) {
            if (!selectedTowerType || state.gold < TOWERS[selectedTowerType].cost) return false;
            if (playerData.towersBuilt >= 15) return false; // Anti-spam

            const gridX = Math.floor(x / CELL);
            const gridY = Math.floor(y / CELL);

            // Check if on path
            if (pathsY.includes(gridY)) return false;

            // Check if position occupied
            const occupied = Object.values(towers).some(tower =>
                Math.abs(tower.x - (gridX * CELL + CELL / 2)) < CELL / 2 &&
                Math.abs(tower.y - (gridY * CELL + CELL / 2)) < CELL / 2
            );
            if (occupied) return false;

            const towerId = Date.now() + '_' + PLAYER_ID;
            const towerData = {
                x: gridX * CELL + CELL / 2,
                y: gridY * CELL + CELL / 2,
                owner: PLAYER_ID,
                type: selectedTowerType,
                level: 1,
                kills: 0,
                cooldown: 0,
                ...TOWERS[selectedTowerType]
            };

            // Update state atomically
            const updates = {};
            updates[`${ROOM}/towers/${towerId}`] = towerData;
            updates[`${ROOM}/state/gold`] = state.gold - TOWERS[selectedTowerType].cost;
            updates[`${ROOM}/players/${PLAYER_ID}/towersBuilt`] = playerData.towersBuilt + 1;

            db.ref().update(updates);
            playerData.towersBuilt++;

            return true;
        }

        function upgradeTower() {
            if (!selectedTowerId) return;

            const tower = towers[selectedTowerId];
            if (!tower || tower.owner !== PLAYER_ID) return;

            const upgradeCost = Math.floor(TOWERS[tower.type].upgradeCost * Math.pow(1.5, tower.level - 1));
            if (state.gold < upgradeCost) return;

            const updates = {};
            updates[`${ROOM}/towers/${selectedTowerId}/level`] = tower.level + 1;
            updates[`${ROOM}/towers/${selectedTowerId}/damage`] = Math.floor(tower.damage * 1.4);
            updates[`${ROOM}/towers/${selectedTowerId}/rate`] = Math.min(tower.rate * 1.2, 5);
            updates[`${ROOM}/towers/${selectedTowerId}/range`] = tower.range * 1.1;
            updates[`${ROOM}/state/gold`] = state.gold - upgradeCost;

            db.ref().update(updates);
            deselectTower();
        }

        function sellTower() {
            if (!selectedTowerId) return;

            const tower = towers[selectedTowerId];
            if (!tower || tower.owner !== PLAYER_ID) return;

            const sellPrice = Math.floor(tower.cost * 0.7);

            const updates = {};
            updates[`${ROOM}/towers/${selectedTowerId}`] = null;
            updates[`${ROOM}/state/gold`] = state.gold + sellPrice;
            updates[`${ROOM}/players/${PLAYER_ID}/towersBuilt`] = Math.max(0, playerData.towersBuilt - 1);

            db.ref().update(updates);
            playerData.towersBuilt = Math.max(0, playerData.towersBuilt - 1);
            deselectTower();
        }

        /* ================= WAVE FUNCTIONS ================= */
        function startWave() {
            if (state.waveActive) return;

            const newWave = state.wave + 1;
            stateRef.update({ wave: newWave, waveActive: true });

            const enemyCount = 8 + newWave * 2;
            let spawned = 0;

            const spawnInterval = setInterval(() => {
                spawnEnemy(newWave);
                spawned++;

                if (spawned >= enemyCount) {
                    clearInterval(spawnInterval);
                    // Check wave completion after delay
                    setTimeout(checkWaveCompletion, 2000);
                }
            }, 1500);
        }

        function spawnEnemy(wave) {
            const lane = pathsY[Math.floor(Math.random() * pathsY.length)];
            let type = 'BASIC';

            if (wave > 3 && Math.random() < 0.3) type = 'FAST';
            if (wave > 6 && Math.random() < 0.25) type = 'TANK';

            const enemyTemplate = ENEMIES[type];
            const waveMultiplier = 1 + wave * 0.15;

            const enemyId = Date.now() + '_' + Math.random().toString(36).slice(2);
            const enemyData = {
                x: -20,
                y: lane * CELL + CELL / 2,
                type,
                hp: Math.floor(enemyTemplate.hp * waveMultiplier),
                maxHp: Math.floor(enemyTemplate.hp * waveMultiplier),
                speed: enemyTemplate.speed,
                value: enemyTemplate.value,
                color: enemyTemplate.color
            };

            enemiesRef.child(enemyId).set(enemyData);
        }

        function checkWaveCompletion() {
            if (Object.keys(enemies).length === 0 && state.waveActive) {
                stateRef.update({ waveActive: false });
            }
        }

        /* ================= GAME LOOP ================= */
        let lastTime = performance.now();

        function gameLoop(currentTime) {
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            updateGame(deltaTime);
            draw();
            requestAnimationFrame(gameLoop);
        }

        function updateGame(dt) {
            // Update enemies
            const enemyUpdates = {};
            const enemiesToRemove = [];

            Object.entries(enemies).forEach(([id, enemy]) => {
                enemy.x += enemy.speed * dt;

                if (enemy.x > canvas.width + 50) {
                    // Enemy reached base
                    enemiesToRemove.push(id);
                    if (state.baseHP > 1) {
                        stateRef.child('baseHP').set(state.baseHP - 1);
                    }
                } else {
                    enemyUpdates[id] = { x: enemy.x };
                }
            });

            // Remove enemies that reached base
            enemiesToRemove.forEach(id => {
                enemiesRef.child(id).remove();
            });

            // Update enemy positions in batch
            if (Object.keys(enemyUpdates).length > 0) {
                const updates = {};
                Object.entries(enemyUpdates).forEach(([id, data]) => {
                    updates[`${ROOM}/enemies/${id}/x`] = data.x;
                });
                db.ref().update(updates);
            }

            // Tower combat
            updateTowerCombat(dt);
        }

        function updateTowerCombat(dt) {
            const combatUpdates = {};

            Object.entries(towers).forEach(([towerId, tower]) => {
                tower.cooldown = Math.max(0, tower.cooldown - dt);

                if (tower.cooldown <= 0) {
                    // Find target
                    let target = null;
                    let closestDistance = tower.range;

                    Object.entries(enemies).forEach(([enemyId, enemy]) => {
                        const distance = Math.hypot(enemy.x - tower.x, enemy.y - tower.y);
                        if (distance < closestDistance) {
                            closestDistance = distance;
                            target = { id: enemyId, enemy };
                        }
                    });

                    if (target) {
                        // Attack
                        const newHp = target.enemy.hp - tower.damage;
                        tower.cooldown = 1 / tower.rate;

                        combatUpdates[`${ROOM}/towers/${towerId}/cooldown`] = tower.cooldown;

                        if (newHp <= 0) {
                            // Enemy killed
                            combatUpdates[`${ROOM}/enemies/${target.id}`] = null;
                            combatUpdates[`${ROOM}/state/gold`] = state.gold + target.enemy.value;
                            combatUpdates[`${ROOM}/towers/${towerId}/kills`] = (tower.kills || 0) + 1;
                            combatUpdates[`${ROOM}/players/${tower.owner}/score`] = (players[tower.owner]?.score || 0) + target.enemy.value;

                            // Update local player score
                            if (tower.owner === PLAYER_ID) {
                                playerData.score += target.enemy.value;
                            }
                        } else {
                            combatUpdates[`${ROOM}/enemies/${target.id}/hp`] = newHp;
                        }
                    }
                }
            });

            // Apply combat updates
            if (Object.keys(combatUpdates).length > 0) {
                db.ref().update(combatUpdates);
            }
        }

        /* ================= RENDERING ================= */
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            for (let x = 0; x <= GRID_WIDTH; x++) {
                ctx.beginPath();
                ctx.moveTo(x * CELL, 0);
                ctx.lineTo(x * CELL, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= GRID_HEIGHT; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * CELL);
                ctx.lineTo(canvas.width, y * CELL);
                ctx.stroke();
            }

            // Draw paths
            ctx.fillStyle = '#444';
            pathsY.forEach(y => {
                ctx.fillRect(0, y * CELL, canvas.width, CELL);
            });

            // Draw towers
            Object.entries(towers).forEach(([id, tower]) => {
                // Range indicator for selected tower
                if (id === selectedTowerId) {
                    ctx.strokeStyle = tower.color + '40';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(tower.x, tower.y, tower.range, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Tower body
                ctx.fillStyle = tower.color;
                ctx.beginPath();
                ctx.arc(tower.x, tower.y, 12 + tower.level, 0, Math.PI * 2);
                ctx.fill();

                // Owner indicator
                if (tower.owner === PLAYER_ID) {
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(tower.x, tower.y, 12 + tower.level + 2, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Level text
                ctx.fillStyle = '#fff';
                ctx.font = '12px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(tower.level, tower.x, tower.y - 20);

                // Kill count
                if (tower.kills > 0) {
                    ctx.fillStyle = '#ffff00';
                    ctx.font = '10px monospace';
                    ctx.fillText(tower.kills, tower.x, tower.y + 25);
                }
            });

            // Draw enemies
            Object.values(enemies).forEach(enemy => {
                // Enemy body
                ctx.fillStyle = enemy.color;
                ctx.beginPath();
                ctx.arc(enemy.x, enemy.y, 8, 0, Math.PI * 2);
                ctx.fill();

                // Health bar
                const barWidth = 20;
                const barHeight = 4;
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(enemy.x - barWidth / 2, enemy.y - 15, barWidth, barHeight);
                ctx.fillStyle = '#00ff00';
                ctx.fillRect(enemy.x - barWidth / 2, enemy.y - 15, (enemy.hp / enemy.maxHp) * barWidth, barHeight);
            });
        }

        /* ================= EVENT LISTENERS ================= */
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Check if clicking on existing tower
            let clickedTowerId = null;
            Object.entries(towers).forEach(([id, tower]) => {
                if (Math.hypot(tower.x - x, tower.y - y) < 15) {
                    clickedTowerId = id;
                }
            });

            if (clickedTowerId) {
                const tower = towers[clickedTowerId];
                if (tower.owner === PLAYER_ID) {
                    selectTowerById(clickedTowerId);
                }
            } else {
                buildTower(x, y);
            }
        });

        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Quick upgrade on right click
            Object.entries(towers).forEach(([id, tower]) => {
                if (Math.hypot(tower.x - x, tower.y - y) < 15 && tower.owner === PLAYER_ID) {
                    selectedTowerId = id;
                    upgradeTower();
                }
            });
        });

        // Initialize UI
        document.getElementById('playerId').textContent = playerData.name;

        // Start game loop
        requestAnimationFrame(gameLoop);
    </script>
</body>

</html>
