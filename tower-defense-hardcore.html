<!DOCTYPE html>
<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tower Defense Hardcore</title>
<style>
    body {
        margin: 0;
        padding: 0;
        background: #0a0a0a;
        color: #fff;
        font-family: monospace;
        overflow: hidden;
    }

    canvas {
        display: block;
        border: 2px solid #333;
    }

    .ui {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 10;
    }

    .stats {
        display: flex;
        gap: 20px;
        margin-bottom: 10px;
    }

    .stat {
        background: rgba(0, 0, 0, 0.8);
        padding: 5px 10px;
        border-radius: 4px;
    }

    .towers {
        display: flex;
        gap: 10px;
        margin-bottom: 10px;
    }

    .tower-btn {
        background: #333;
        border: none;
        color: #fff;
        padding: 8px 12px;
        cursor: pointer;
        border-radius: 4px;
    }

    .tower-btn:hover {
        background: #555;
    }

    .tower-btn.selected {
        background: #0a84ff;
    }

    .wave-btn {
        background: #ff3b30;
        border: none;
        color: #fff;
        padding: 10px 20px;
        cursor: pointer;
        border-radius: 4px;
        font-weight: bold;
    }

    .wave-btn:hover {
        background: #ff6b60;
    }

    .leaderboard {
        position: absolute;
        top: 10px;
        right: 10px;
        background: rgba(0, 0, 0, 0.9);
        padding: 10px;
        border-radius: 4px;
        min-width: 200px;
    }

    .elite-indicator {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(255, 0, 0, 0.8);
        padding: 20px;
        border-radius: 8px;
        font-size: 18px;
        font-weight: bold;
        display: none;
    }

    .synergy-panel {
        position: absolute;
        bottom: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.9);
        padding: 10px;
        border-radius: 4px;
        max-width: 300px;
    }
</style>
</head>

<body>
    <canvas id="gameCanvas" width="1200" height="800"></canvas>

    <div class="ui">
        <div class="stats">
            <div class="stat">üí∞ Gold: <span id="gold">100</span></div>
            <div class="stat">‚ù§Ô∏è Base: <span id="baseHp">20</span></div>
            <div class="stat">üåä Wave: <span id="wave">0</span></div>
            <div class="stat">‚ö° Score: <span id="score">0</span></div>
        </div>

        <div class="towers">
            <button class="tower-btn selected" data-type="basic">‚ö° Basic (25)</button>
            <button class="tower-btn" data-type="fast">üöÄ Fast (40)</button>
            <button class="tower-btn" data-type="heavy">üí™ Heavy (60)</button>
            <button class="tower-btn" data-type="laser">üî• Laser (100)</button>
            <button class="tower-btn" data-type="freeze">‚ùÑÔ∏è Freeze (80)</button>
        </div>

        <button class="wave-btn" id="startWave">üåä Start Wave 1</button>
    </div>

    <div class="leaderboard">
        <div style="font-weight: bold; margin-bottom: 10px;">üèÜ Leaderboard</div>
        <div id="leaderboardList"></div>
    </div>

    <div class="elite-indicator" id="eliteWarning">
        ‚ö†Ô∏è ELITE WAVE INCOMING ‚ö†Ô∏è
    </div>

    <div class="synergy-panel">
        <div style="font-weight: bold; margin-bottom: 5px;">üîó Active Synergies</div>
        <div id="synergyList">None</div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game State
        let gold = 100;
        let baseHp = 20;
        let wave = 0;
        let gameRunning = false;
        let selectedTowerType = 'basic';
        let selectedTower = null;

        // Player
        const player = {
            id: 'player_' + Math.random().toString(36).slice(2),
            score: 0,
            towersBuilt: 0
        };

        // Collections
        const towers = [];
        const enemies = [];
        const projectiles = [];
        const effects = [];
        const leaderboard = {};

        // Enhanced Tower Types with new abilities
        const TOWERS = {
            basic: { cost: 25, damage: 10, fireRate: 1, range: 80, color: '#00d4ff' },
            fast: { cost: 40, damage: 8, fireRate: 2.5, range: 70, color: '#a855f7' },
            heavy: { cost: 60, damage: 25, fireRate: 0.6, range: 90, color: '#f59e0b' },
            laser: { cost: 100, damage: 15, fireRate: 3, range: 120, color: '#ff0040', piercing: true },
            freeze: { cost: 80, damage: 5, fireRate: 1.5, range: 85, color: '#40e0ff', slow: 0.5 }
        };

        // Elite Enemy Types
        const ELITE_ENEMIES = {
            berserker: { hp: 200, speed: 35, value: 25, color: '#ff4444', ability: 'rage' },
            shielded: { hp: 150, speed: 20, value: 20, color: '#4444ff', ability: 'shield' },
            regenerator: { hp: 120, speed: 25, value: 18, color: '#44ff44', ability: 'regen' },
            splitter: { hp: 80, speed: 30, value: 15, color: '#ff44ff', ability: 'split' },
            ghost: { hp: 100, speed: 40, value: 22, color: '#ffffff', ability: 'phase' }
        };

        // Synergy System
        const SYNERGIES = {
            'basic+fast': { name: 'Rapid Fire', bonus: 'fireRate', multiplier: 1.3 },
            'heavy+laser': { name: 'Devastator', bonus: 'damage', multiplier: 1.5 },
            'freeze+laser': { name: 'Cryo Beam', bonus: 'slow', multiplier: 2 },
            'basic+heavy': { name: 'Balanced', bonus: 'range', multiplier: 1.2 }
        };

        // Path system
        const paths = [
            [
                { x: 0, y: 200 }, { x: 200, y: 200 }, { x: 200, y: 400 },
                { x: 600, y: 400 }, { x: 600, y: 200 }, { x: 1200, y: 200 }
            ],
            [
                { x: 0, y: 300 }, { x: 300, y: 300 }, { x: 300, y: 600 },
                { x: 800, y: 600 }, { x: 800, y: 300 }, { x: 1200, y: 300 }
            ],
            [
                { x: 0, y: 500 }, { x: 400, y: 500 }, { x: 400, y: 100 },
                { x: 900, y: 100 }, { x: 900, y: 500 }, { x: 1200, y: 500 }
            ]
        ];

        function createTower(type, x, y) {
            const base = TOWERS[type];
            return {
                id: crypto.randomUUID(),
                owner: player.id,
                type,
                x, y,
                level: 1,
                cost: base.cost,
                damage: base.damage,
                fireRate: base.fireRate,
                range: base.range,
                cooldown: 0,
                kills: 0,
                color: base.color,
                piercing: base.piercing || false,
                slow: base.slow || 0
            };
        }

        function createEnemy(type, pathIndex, isElite = false) {
            const waveMultiplier = 1 + wave * 0.15;
            let enemy;

            if (isElite && ELITE_ENEMIES[type]) {
                const elite = ELITE_ENEMIES[type];
                enemy = {
                    id: crypto.randomUUID(),
                    type: 'elite_' + type,
                    hp: elite.hp * waveMultiplier,
                    maxHp: elite.hp * waveMultiplier,
                    speed: elite.speed,
                    value: elite.value,
                    color: elite.color,
                    pathIndex,
                    pathProgress: 0,
                    x: paths[pathIndex][0].x,
                    y: paths[pathIndex][0].y,
                    isElite: true,
                    ability: elite.ability,
                    abilityTimer: 0,
                    shield: elite.ability === 'shield' ? 50 : 0,
                    slowEffect: 1,
                    slowTimer: 0
                };
            } else {
                const baseHp = type === 'tank' ? 80 : type === 'fast' ? 30 : 50;
                const baseSpeed = type === 'tank' ? 15 : type === 'fast' ? 35 : 25;
                const baseValue = type === 'tank' ? 8 : type === 'fast' ? 6 : 5;

                enemy = {
                    id: crypto.randomUUID(),
                    type,
                    hp: baseHp * waveMultiplier,
                    maxHp: baseHp * waveMultiplier,
                    speed: baseSpeed,
                    value: baseValue,
                    color: type === 'tank' ? '#8b0000' : type === 'fast' ? '#ff8c00' : '#dc143c',
                    pathIndex,
                    pathProgress: 0,
                    x: paths[pathIndex][0].x,
                    y: paths[pathIndex][0].y,
                    isElite: false,
                    slowEffect: 1,
                    slowTimer: 0
                };
            }

            return enemy;
        }

        function upgradeTower(tower) {
            const upgradeCost = Math.floor(tower.cost * tower.level * 0.8);
            if (gold < upgradeCost) return false;

            gold -= upgradeCost;
            tower.level++;
            tower.damage = Math.floor(tower.damage * 1.4);
            tower.fireRate = Math.min(tower.fireRate * 1.25, 5);
            tower.range *= 1.15;

            // Special upgrade bonuses
            if (tower.level === 3) {
                if (tower.type === 'laser') tower.piercing = true;
                if (tower.type === 'freeze') tower.slow *= 1.5;
            }

            updateUI();
            return true;
        }

        function calculateSynergies() {
            const activeSynergies = [];
            const towerTypes = {};

            // Count tower types
            towers.forEach(t => {
                towerTypes[t.type] = (towerTypes[t.type] || 0) + 1;
            });

            // Check synergies
            Object.entries(SYNERGIES).forEach(([combo, synergy]) => {
                const [type1, type2] = combo.split('+');
                if (towerTypes[type1] && towerTypes[type2]) {
                    activeSynergies.push(synergy);
                }
            });

            return activeSynergies;
        }

        function applySynergies(tower) {
            const synergies = calculateSynergies();
            let multiplier = 1;

            synergies.forEach(synergy => {
                if (synergy.bonus === 'fireRate' && (tower.type === 'basic' || tower.type === 'fast')) {
                    multiplier *= synergy.multiplier;
                } else if (synergy.bonus === 'damage' && (tower.type === 'heavy' || tower.type === 'laser')) {
                    multiplier *= synergy.multiplier;
                } else if (synergy.bonus === 'range') {
                    multiplier *= synergy.multiplier;
                }
            });

            return multiplier;
        }

        function spawnWave() {
            const isEliteWave = wave % 5 === 0 && wave > 0;
            const enemyCount = 8 + wave * 2;

            if (isEliteWave) {
                document.getElementById('eliteWarning').style.display = 'block';
                setTimeout(() => {
                    document.getElementById('eliteWarning').style.display = 'none';
                }, 2000);
            }

            for (let i = 0; i < enemyCount; i++) {
                setTimeout(() => {
                    const pathIndex = Math.floor(Math.random() * paths.length);
                    let enemy;

                    if (isEliteWave && Math.random() < 0.4) {
                        const eliteTypes = Object.keys(ELITE_ENEMIES);
                        const eliteType = eliteTypes[Math.floor(Math.random() * eliteTypes.length)];
                        enemy = createEnemy(eliteType, pathIndex, true);
                    } else {
                        const types = ['basic', 'fast', 'tank'];
                        const weights = wave < 3 ? [0.7, 0.2, 0.1] : wave < 8 ? [0.4, 0.4, 0.2] : [0.3, 0.3, 0.4];
                        const rand = Math.random();
                        let type = 'basic';

                        if (rand < weights[0]) type = 'basic';
                        else if (rand < weights[0] + weights[1]) type = 'fast';
                        else type = 'tank';

                        enemy = createEnemy(type, pathIndex);
                    }

                    enemies.push(enemy);
                }, i * (isEliteWave ? 800 : 500));
            }
        }

        function updateEnemies(deltaTime) {
            enemies.forEach((enemy, index) => {
                // Handle slow effects
                if (enemy.slowTimer > 0) {
                    enemy.slowTimer -= deltaTime;
                    if (enemy.slowTimer <= 0) {
                        enemy.slowEffect = 1;
                    }
                }

                // Elite abilities
                if (enemy.isElite) {
                    enemy.abilityTimer += deltaTime;

                    switch (enemy.ability) {
                        case 'rage':
                            if (enemy.hp < enemy.maxHp * 0.5) {
                                enemy.speed = ELITE_ENEMIES.berserker.speed * 1.5;
                                enemy.color = '#ff0000';
                            }
                            break;
                        case 'regen':
                            if (enemy.abilityTimer > 2000) {
                                enemy.hp = Math.min(enemy.hp + enemy.maxHp * 0.1, enemy.maxHp);
                                enemy.abilityTimer = 0;
                            }
                            break;
                        case 'phase':
                            if (enemy.abilityTimer > 3000) {
                                enemy.color = enemy.color === '#ffffff' ? '#888888' : '#ffffff';
                                enemy.abilityTimer = 0;
                            }
                            break;
                    }
                }

                // Movement
                const path = paths[enemy.pathIndex];
                const currentSpeed = enemy.speed * enemy.slowEffect;
                enemy.pathProgress += currentSpeed * deltaTime / 1000;

                const totalDistance = path.length - 1;
                const progress = Math.min(enemy.pathProgress / 100, totalDistance);

                if (progress >= totalDistance) {
                    // Enemy reached base
                    baseHp--;
                    enemies.splice(index, 1);
                    if (baseHp <= 0) {
                        gameOver();
                    }
                    return;
                }

                const segmentIndex = Math.floor(progress);
                const segmentProgress = progress - segmentIndex;

                if (segmentIndex < path.length - 1) {
                    const start = path[segmentIndex];
                    const end = path[segmentIndex + 1];

                    enemy.x = start.x + (end.x - start.x) * segmentProgress;
                    enemy.y = start.y + (end.y - start.y) * segmentProgress;
                }
            });
        }

        function updateTowers(deltaTime) {
            towers.forEach(tower => {
                tower.cooldown = Math.max(0, tower.cooldown - deltaTime);

                if (tower.cooldown <= 0) {
                    // Find target
                    let target = null;
                    let closestDistance = tower.range;

                    enemies.forEach(enemy => {
                        const distance = Math.hypot(enemy.x - tower.x, enemy.y - tower.y);
                        if (distance < closestDistance) {
                            // Ghost phase check
                            if (enemy.ability === 'phase' && enemy.color === '#888888') {
                                if (Math.random() < 0.7) return; // 70% miss chance
                            }

                            closestDistance = distance;
                            target = enemy;
                        }
                    });

                    if (target) {
                        // Apply synergy bonuses
                        const synergyMultiplier = applySynergies(tower);
                        const actualFireRate = tower.fireRate * synergyMultiplier;

                        tower.cooldown = 1000 / actualFireRate;

                        // Create projectile
                        projectiles.push({
                            id: crypto.randomUUID(),
                            x: tower.x,
                            y: tower.y,
                            targetX: target.x,
                            targetY: target.y,
                            damage: tower.damage,
                            speed: 400,
                            color: tower.color,
                            piercing: tower.piercing,
                            slow: tower.slow,
                            ownerId: tower.owner
                        });
                    }
                }
            });
        }

        function updateProjectiles(deltaTime) {
            projectiles.forEach((proj, index) => {
                const dx = proj.targetX - proj.x;
                const dy = proj.targetY - proj.y;
                const distance = Math.hypot(dx, dy);

                if (distance < 5) {
                    // Hit
                    const hitEnemies = [];

                    enemies.forEach(enemy => {
                        const hitDistance = Math.hypot(enemy.x - proj.targetX, enemy.y - proj.targetY);
                        if (hitDistance < 20) {
                            hitEnemies.push(enemy);
                        }
                    });

                    hitEnemies.forEach(enemy => {
                        let damage = proj.damage;

                        // Shield check
                        if (enemy.shield > 0) {
                            const shieldDamage = Math.min(damage, enemy.shield);
                            enemy.shield -= shieldDamage;
                            damage -= shieldDamage;
                        }

                        enemy.hp -= damage;

                        // Apply slow effect
                        if (proj.slow > 0) {
                            enemy.slowEffect = Math.max(0.2, 1 - proj.slow);
                            enemy.slowTimer = 2000;
                        }

                        // Create hit effect
                        effects.push({
                            x: enemy.x,
                            y: enemy.y,
                            type: 'hit',
                            timer: 300,
                            color: proj.color
                        });

                        if (enemy.hp <= 0) {
                            // Enemy killed
                            gold += enemy.value;
                            player.score += enemy.value;

                            // Find tower owner
                            const ownerTower = towers.find(t => t.owner === proj.ownerId);
                            if (ownerTower) {
                                ownerTower.kills++;
                            }

                            // Handle splitter ability
                            if (enemy.ability === 'split' && enemy.hp <= 0) {
                                for (let i = 0; i < 2; i++) {
                                    const splitEnemy = createEnemy('basic', enemy.pathIndex);
                                    splitEnemy.x = enemy.x + (Math.random() - 0.5) * 40;
                                    splitEnemy.y = enemy.y + (Math.random() - 0.5) * 40;
                                    splitEnemy.hp = enemy.maxHp * 0.3;
                                    splitEnemy.maxHp = enemy.maxHp * 0.3;
                                    splitEnemy.pathProgress = enemy.pathProgress;
                                    enemies.push(splitEnemy);
                                }
                            }

                            enemies.splice(enemies.indexOf(enemy), 1);
                        }

                        if (!proj.piercing) break;
                    });

                    projectiles.splice(index, 1);
                } else {
                    // Move projectile
                    const moveDistance = proj.speed * deltaTime / 1000;
                    proj.x += (dx / distance) * moveDistance;
                    proj.y += (dy / distance) * moveDistance;
                }
            });
        }

        function updateEffects(deltaTime) {
            effects.forEach((effect, index) => {
                effect.timer -= deltaTime;
                if (effect.timer <= 0) {
                    effects.splice(index, 1);
                }
            });
        }

        function draw() {
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw paths
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 20;
            paths.forEach(path => {
                ctx.beginPath();
                ctx.moveTo(path[0].x, path[0].y);
                path.forEach(point => ctx.lineTo(point.x, point.y));
                ctx.stroke();
            });

            // Draw towers
            towers.forEach(tower => {
                // Range indicator for selected tower
                if (selectedTower === tower) {
                    ctx.strokeStyle = tower.color + '40';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(tower.x, tower.y, tower.range, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Tower body
                ctx.fillStyle = tower.color;
                ctx.beginPath();
                ctx.arc(tower.x, tower.y, 12 + tower.level * 2, 0, Math.PI * 2);
                ctx.fill();

                // Level indicator
                ctx.fillStyle = '#fff';
                ctx.font = '12px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(tower.level, tower.x, tower.y - 18);

                // Kill count
                if (tower.kills > 0) {
                    ctx.fillStyle = '#ffff00';
                    ctx.font = '10px monospace';
                    ctx.fillText(tower.kills, tower.x, tower.y + 25);
                }
            });

            // Draw enemies
            enemies.forEach(enemy => {
                // Enemy body
                ctx.fillStyle = enemy.color;
                ctx.beginPath();
                const size = enemy.isElite ? 8 : 6;
                ctx.arc(enemy.x, enemy.y, size, 0, Math.PI * 2);
                ctx.fill();

                // Elite indicator
                if (enemy.isElite) {
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(enemy.x, enemy.y, size + 2, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Health bar
                const barWidth = 20;
                const barHeight = 4;
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(enemy.x - barWidth / 2, enemy.y - 15, barWidth, barHeight);
                ctx.fillStyle = '#00ff00';
                ctx.fillRect(enemy.x - barWidth / 2, enemy.y - 15, (enemy.hp / enemy.maxHp) * barWidth, barHeight);

                // Shield bar
                if (enemy.shield > 0) {
                    ctx.fillStyle = '#0080ff';
                    ctx.fillRect(enemy.x - barWidth / 2, enemy.y - 20, (enemy.shield / 50) * barWidth, 2);
                }

                // Slow effect
                if (enemy.slowEffect < 1) {
                    ctx.fillStyle = '#40e0ff80';
                    ctx.beginPath();
                    ctx.arc(enemy.x, enemy.y, size + 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // Draw projectiles
            projectiles.forEach(proj => {
                ctx.fillStyle = proj.color;
                ctx.beginPath();
                ctx.arc(proj.x, proj.y, 3, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw effects
            effects.forEach(effect => {
                const alpha = effect.timer / 300;
                ctx.fillStyle = effect.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                ctx.beginPath();
                ctx.arc(effect.x, effect.y, 8 * (1 - alpha), 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function updateUI() {
            document.getElementById('gold').textContent = gold;
            document.getElementById('baseHp').textContent = baseHp;
            document.getElementById('wave').textContent = wave;
            document.getElementById('score').textContent = player.score;

            // Update leaderboard
            leaderboard[player.id] = player.score;
            const entries = Object.entries(leaderboard)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5);

            document.getElementById('leaderboardList').innerHTML = entries
                .map(([id, score], i) => `${i + 1}. ${id.slice(-4)}: ${score}`)
                .join('<br>');

            // Update synergies
            const synergies = calculateSynergies();
            document.getElementById('synergyList').innerHTML = synergies.length > 0
                ? synergies.map(s => `üîó ${s.name}`).join('<br>')
                : 'None';
        }

        function gameLoop() {
            const deltaTime = 16; // ~60fps

            if (gameRunning) {
                updateEnemies(deltaTime);
                updateTowers(deltaTime);
                updateProjectiles(deltaTime);
                updateEffects(deltaTime);

                // Check wave completion
                if (enemies.length === 0 && gameRunning) {
                    gameRunning = false;
                    document.getElementById('startWave').textContent = `üåä Start Wave ${wave + 1}`;
                    document.getElementById('startWave').style.display = 'block';
                }
            }

            draw();
            updateUI();
            requestAnimationFrame(gameLoop);
        }

        function gameOver() {
            gameRunning = false;
            alert(`Game Over! Final Score: ${player.score}`);
            location.reload();
        }

        // Event Listeners
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Check if clicking on existing tower
            let clickedTower = null;
            for (const tower of towers) {
                if (Math.hypot(tower.x - x, tower.y - y) < 15) {
                    clickedTower = tower;
                    break;
                }
            }

            if (clickedTower) {
                selectedTower = selectedTower === clickedTower ? null : clickedTower;
            } else {
                // Build new tower
                const towerCost = TOWERS[selectedTowerType].cost;
                if (gold >= towerCost && player.towersBuilt < 20) {
                    // Check if position is valid (not on path)
                    let validPosition = true;
                    paths.forEach(path => {
                        path.forEach(point => {
                            if (Math.hypot(point.x - x, point.y - y) < 30) {
                                validPosition = false;
                            }
                        });
                    });

                    if (validPosition) {
                        const tower = createTower(selectedTowerType, x, y);
                        towers.push(tower);
                        gold -= towerCost;
                        player.towersBuilt++;
                        selectedTower = null;
                    }
                }
            }
        });

        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            if (selectedTower && selectedTower.owner === player.id) {
                upgradeTower(selectedTower);
            }
        });

        // UI Event Listeners
        document.querySelectorAll('.tower-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.tower-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                selectedTowerType = btn.dataset.type;
            });
        });

        document.getElementById('startWave').addEventListener('click', () => {
            wave++;
            gameRunning = true;
            spawnWave();
            document.getElementById('startWave').style.display = 'none';
        });

        // Start game loop
        gameLoop();
    </script>
</body>

</html>
